"""
Vulnerability Tracking Module for OpenClaw Inventory
=====================================================

Automatically scans software inventory against NVD (National Vulnerability Database)
to identify known CVEs affecting your fleet.

Features:
- Async CVE lookup via NVD API 2.0
- CVSS v3.1 severity scoring
- Caching to reduce API calls
- Batch processing for large fleets
- CPE (Common Platform Enumeration) matching
"""

import asyncio
import hashlib
import json
import logging
import re
from datetime import datetime, timedelta
from typing import Optional
from urllib.parse import quote

import aiohttp

logger = logging.getLogger(__name__)

# NVD API Configuration
NVD_API_BASE = "https://services.nvd.nist.gov/rest/json/cves/2.0"
NVD_RATE_LIMIT_DELAY = 0.6  # 6 seconds per request without API key, 0.6 with key

# Severity thresholds (CVSS v3.1)
SEVERITY_CRITICAL = 9.0
SEVERITY_HIGH = 7.0
SEVERITY_MEDIUM = 4.0


class VulnerabilityScanner:
    """
    Scans software inventory against NVD to find vulnerabilities.
    """

    def __init__(self, db_pool, nvd_api_key: Optional[str] = None):
        self.db_pool = db_pool
        self.nvd_api_key = nvd_api_key
        self.rate_limit = 0.6 if nvd_api_key else 6.0  # With key: 10 req/s, without: 5 req/30s
        self._cache: dict[str, tuple[datetime, list]] = {}
        self._cache_ttl = timedelta(hours=24)

    async def _get_api_key(self) -> Optional[str]:
        """Get NVD API key from environment or database."""
        import os
        # First check environment
        key = os.environ.get("NVD_API_KEY") or self.nvd_api_key
        if key:
            return key
        # Then check database
        try:
            async with self.db_pool.acquire() as conn:
                row = await conn.fetchrow("SELECT value FROM system_settings WHERE key = 'nvd_api_key'")
                if row and row["value"]:
                    return row["value"]
        except Exception:
            pass
        return None

    async def scan_all_nodes(self) -> dict:
        """
        Scan all nodes for vulnerabilities.
        Returns summary statistics.
        """
        # Get API key (may have been set via UI)
        api_key = await self._get_api_key()
        if api_key:
            self.nvd_api_key = api_key
            self.rate_limit = 0.6
        else:
            self.rate_limit = 6.0

        async with self.db_pool.acquire() as conn:
            # Get all unique software from inventory
            rows = await conn.fetch("""
                SELECT DISTINCT 
                    s.name,
                    s.version,
                    s.publisher
                FROM software_current s
                WHERE s.version IS NOT NULL 
                  AND s.version != ''
                  AND s.name NOT LIKE 'Update for%'
                  AND s.name NOT LIKE 'Security Update%'
                  AND s.name NOT LIKE 'Hotfix%'
                ORDER BY s.name
            """)

        logger.info(f"Scanning {len(rows)} unique software packages for vulnerabilities")

        total_vulns = 0
        critical_count = 0
        high_count = 0
        scanned = 0

        for row in rows:
            software_name = row["name"]
            version = row["version"]

            vulns = await self.check_software(software_name, version)
            if vulns:
                await self._store_vulnerabilities(software_name, version, vulns)
                total_vulns += len(vulns)
                critical_count += sum(1 for v in vulns if v.get("severity") == "CRITICAL")
                high_count += sum(1 for v in vulns if v.get("severity") == "HIGH")

            scanned += 1
            if scanned % 50 == 0:
                logger.info(f"Progress: {scanned}/{len(rows)} packages scanned")

            # Rate limiting
            await asyncio.sleep(self.rate_limit)

        return {
            "scanned_packages": len(rows),
            "total_vulnerabilities": total_vulns,
            "critical": critical_count,
            "high": high_count,
            "scan_completed_at": datetime.utcnow().isoformat()
        }

    async def check_software(self, name: str, version: str) -> list[dict]:
        """
        Check a single software package for known CVEs.
        """
        # Check cache first
        cache_key = f"{name}:{version}"
        if cache_key in self._cache:
            cached_time, cached_result = self._cache[cache_key]
            if datetime.utcnow() - cached_time < self._cache_ttl:
                return cached_result

        # Normalize software name for search
        search_term = self._normalize_name(name)
        if not search_term:
            return []

        try:
            vulns = await self._query_nvd(search_term, version)
            self._cache[cache_key] = (datetime.utcnow(), vulns)
            return vulns
        except Exception as e:
            logger.error(f"Error checking {name} {version}: {e}")
            return []

    def _normalize_name(self, name: str) -> str:
        """
        Normalize software name for NVD search.
        Remove version numbers, editions, architecture info.
        """
        # Common patterns to remove
        patterns = [
            r'\s*\(x64\)',
            r'\s*\(x86\)',
            r'\s*\(64-bit\)',
            r'\s*\(32-bit\)',
            r'\s*x64',
            r'\s*x86',
            r'\s*-\s*\d+\.\d+.*$',
            r'\s+\d+\.\d+.*$',
            r'\s+v\d+.*$',
            r'\s+Version\s+\d+.*$',
            r'\s+Edition.*$',
            r'\s+Update.*$',
        ]

        result = name
        for pattern in patterns:
            result = re.sub(pattern, '', result, flags=re.IGNORECASE)

        # Clean up
        result = result.strip()
        result = re.sub(r'\s+', ' ', result)

        return result

    async def _query_nvd(self, keyword: str, version: str) -> list[dict]:
        """
        Query NVD API for CVEs matching the keyword.
        """
        params = {
            "keywordSearch": keyword,
            "resultsPerPage": 50,
        }

        headers = {}
        if self.nvd_api_key:
            headers["apiKey"] = self.nvd_api_key

        async with aiohttp.ClientSession() as session:
            url = f"{NVD_API_BASE}?keywordSearch={quote(keyword)}&resultsPerPage=50"
            async with session.get(url, headers=headers, timeout=30) as response:
                if response.status == 403:
                    logger.warning("NVD API rate limited, backing off...")
                    await asyncio.sleep(30)
                    return []

                if response.status != 200:
                    logger.error(f"NVD API error: {response.status}")
                    return []

                data = await response.json()

        vulnerabilities = []
        for item in data.get("vulnerabilities", []):
            cve = item.get("cve", {})
            cve_id = cve.get("id", "")

            # Check if this CVE applies to our version
            if not self._version_affected(cve, version):
                continue

            # Extract CVSS score
            cvss_data = self._extract_cvss(cve)

            # Extract description
            descriptions = cve.get("descriptions", [])
            description = ""
            for desc in descriptions:
                if desc.get("lang") == "en":
                    description = desc.get("value", "")
                    break

            vuln = {
                "cve_id": cve_id,
                "description": description[:500] if description else "",
                "cvss_score": cvss_data.get("score"),
                "cvss_vector": cvss_data.get("vector"),
                "severity": cvss_data.get("severity"),
                "published": cve.get("published"),
                "last_modified": cve.get("lastModified"),
                "references": self._extract_references(cve),
            }
            vulnerabilities.append(vuln)

        return vulnerabilities

    def _version_affected(self, cve: dict, target_version: str) -> bool:
        """
        Check if a specific version is affected by the CVE.
        This is a simplified check - production would need CPE matching.
        """
        # For now, include all CVEs found by keyword
        # TODO: Implement proper CPE version range matching
        return True

    def _extract_cvss(self, cve: dict) -> dict:
        """
        Extract CVSS score and severity from CVE data.
        Prefers CVSS v3.1, falls back to v3.0, then v2.0.
        """
        metrics = cve.get("metrics", {})

        # Try CVSS v3.1
        cvss31 = metrics.get("cvssMetricV31", [])
        if cvss31:
            data = cvss31[0].get("cvssData", {})
            return {
                "score": data.get("baseScore"),
                "vector": data.get("vectorString"),
                "severity": data.get("baseSeverity"),
                "version": "3.1"
            }

        # Try CVSS v3.0
        cvss30 = metrics.get("cvssMetricV30", [])
        if cvss30:
            data = cvss30[0].get("cvssData", {})
            return {
                "score": data.get("baseScore"),
                "vector": data.get("vectorString"),
                "severity": data.get("baseSeverity"),
                "version": "3.0"
            }

        # Try CVSS v2.0
        cvss2 = metrics.get("cvssMetricV2", [])
        if cvss2:
            data = cvss2[0].get("cvssData", {})
            score = data.get("baseScore", 0)
            severity = "LOW"
            if score >= 7.0:
                severity = "HIGH"
            elif score >= 4.0:
                severity = "MEDIUM"
            return {
                "score": score,
                "vector": data.get("vectorString"),
                "severity": severity,
                "version": "2.0"
            }

        return {"score": None, "vector": None, "severity": "UNKNOWN", "version": None}

    def _extract_references(self, cve: dict) -> list[str]:
        """
        Extract reference URLs from CVE data.
        """
        refs = cve.get("references", [])
        urls = []
        for ref in refs[:5]:  # Limit to 5 references
            url = ref.get("url")
            if url:
                urls.append(url)
        return urls

    async def _store_vulnerabilities(self, software_name: str, version: str, vulns: list[dict]):
        """
        Store discovered vulnerabilities in database.
        """
        async with self.db_pool.acquire() as conn:
            for vuln in vulns:
                await conn.execute("""
                    INSERT INTO vulnerabilities (
                        software_name, software_version, cve_id, 
                        description, cvss_score, cvss_vector, severity,
                        published_date, reference_urls, discovered_at
                    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW())
                    ON CONFLICT (software_name, software_version, cve_id) 
                    DO UPDATE SET 
                        cvss_score = EXCLUDED.cvss_score,
                        severity = EXCLUDED.severity,
                        last_checked = NOW()
                """,
                    software_name,
                    version,
                    vuln["cve_id"],
                    vuln["description"],
                    vuln["cvss_score"],
                    vuln["cvss_vector"],
                    vuln["severity"],
                    vuln["published"],
                    json.dumps(vuln["references"])
                )


async def get_vulnerability_summary(db_pool) -> dict:
    """
    Get vulnerability summary for dashboard.
    """
    async with db_pool.acquire() as conn:
        # Total vulnerabilities by severity
        severity_counts = await conn.fetch("""
            SELECT severity, COUNT(*) as count
            FROM vulnerabilities
            GROUP BY severity
            ORDER BY 
                CASE severity 
                    WHEN 'CRITICAL' THEN 1
                    WHEN 'HIGH' THEN 2
                    WHEN 'MEDIUM' THEN 3
                    WHEN 'LOW' THEN 4
                    ELSE 5
                END
        """)

        # Affected nodes count
        affected_nodes = await conn.fetchval("""
            SELECT COUNT(DISTINCT s.node_id)
            FROM software_current s
            JOIN vulnerabilities v ON s.name = v.software_name AND s.version = v.software_version
        """)

        # Top 10 critical CVEs
        top_cves = await conn.fetch("""
            SELECT 
                v.cve_id,
                v.software_name,
                v.cvss_score,
                v.severity,
                v.description,
                COUNT(DISTINCT s.node_id) as affected_nodes
            FROM vulnerabilities v
            JOIN software_current s ON s.name = v.software_name AND s.version = v.software_version
            WHERE v.severity IN ('CRITICAL', 'HIGH')
            GROUP BY v.cve_id, v.software_name, v.cvss_score, v.severity, v.description
            ORDER BY v.cvss_score DESC NULLS LAST, affected_nodes DESC
            LIMIT 10
        """)

        # Most vulnerable software
        top_software = await conn.fetch("""
            SELECT 
                v.software_name,
                v.software_version,
                COUNT(*) as vuln_count,
                MAX(v.cvss_score) as max_cvss,
                COUNT(DISTINCT s.node_id) as node_count
            FROM vulnerabilities v
            JOIN software_current s ON s.name = v.software_name AND s.version = v.software_version
            GROUP BY v.software_name, v.software_version
            ORDER BY vuln_count DESC, max_cvss DESC
            LIMIT 10
        """)

        # Last scan info
        last_scan = await conn.fetchrow("""
            SELECT MAX(discovered_at) as last_scan, COUNT(*) as total_vulns
            FROM vulnerabilities
        """)

        return {
            "severity_counts": {row["severity"]: row["count"] for row in severity_counts},
            "affected_nodes": affected_nodes or 0,
            "top_cves": [dict(row) for row in top_cves],
            "top_vulnerable_software": [dict(row) for row in top_software],
            "last_scan": last_scan["last_scan"].isoformat() if last_scan["last_scan"] else None,
            "total_vulnerabilities": last_scan["total_vulns"] or 0
        }


async def get_node_vulnerabilities(db_pool, node_id: str) -> list[dict]:
    """
    Get all vulnerabilities affecting a specific node.
    """
    async with db_pool.acquire() as conn:
        rows = await conn.fetch("""
            SELECT 
                v.cve_id,
                v.software_name,
                v.software_version,
                v.description,
                v.cvss_score,
                v.severity,
                v.published_date,
                v.reference_urls
            FROM vulnerabilities v
            JOIN software_current s ON s.name = v.software_name AND s.version = v.software_version
            WHERE s.node_id = $1
            ORDER BY v.cvss_score DESC NULLS LAST
        """, node_id)

        return [dict(row) for row in rows]
